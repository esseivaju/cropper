#!/usr/bin/env python

import argparse
import os
import sys
import logging
import pathlib
from concurrent.futures import ThreadPoolExecutor
from queue import Queue
from cropper.process_image import process, get_box


def configure_logging():
    handlers = []
    handlers.append(logging.StreamHandler(sys.stdout))
    handlers.append(logging.FileHandler('cropper.log', 'w'))
    logging.basicConfig(handlers=handlers, level=logging.DEBUG,
                        style='{', format="{asctime} | {levelname} | {name} | {module} | {message}")


if __name__ == "__main__":
    configure_logging()
    logger = logging.getLogger(__name__)
    parser = argparse.ArgumentParser()
    parser.add_argument("--src", required=True, help="Source directory containing tif data")
    parser.add_argument("--dst", required=True , help="Destination director where cropped image are saved")
    parser.add_argument("--uniform-size", action="store_true", help="If set, performs a 1st pass across data to find the largest crop region and apply the same crop box to each picture")
    parser.add_argument("--padding-size", default=200, help="Padding area added to the bounding box")
    parser.add_argument('--ignore-realign', action="store_true", help="If set, do not try to rotate picture to deskew the text")
    parser.add_argument("--workers",
                        default=os.cpu_count() * 5,
                        help="Number of workers to use. Default to the number of cpu cores")
    args = parser.parse_args()

    cdir = os.getcwd()
    args.src = os.path.join(cdir, args.src)
    args.dst = os.path.join(cdir, args.dst)

    pathlib.Path(args.dst).mkdir(parents=True, exist_ok=True)

    box = None
    if args.uniform_size:
        logger.info("Searching for largest box...")
        boxes_queue = Queue()
        # 1st pass -- search for largest bounding box amongst all images
        with ThreadPoolExecutor(max_workers=args.workers) as executor:
            for dirpath, dirnames, filenames in os.walk(args.src):
                for filename in filenames:
                    if filename.endswith(".tif"):
                        executor.submit(get_box,
                                        os.path.join(dirpath, filename),
                                        boxes_queue)
        largest_w = largest_h = 0
        while not boxes_queue.empty():
            box = boxes_queue.get()[1]
            # boxes can be horizontal or vertical, we want vertical boxes (i.e. height > width) --> invert width / height if needed
            w_index = 0 if box[0] < box[1] else 1
            h_index = 1 - w_index
            if largest_w < box[w_index]:
                largest_w = box[w_index]
            if largest_h < box[h_index]:
                largest_h = box[h_index]
        logger.info(f"Largest box: {largest_w}x{largest_h}")
        box = (largest_w, largest_h)

    # 2nd pass -- crop pictures to the largest box
    with ThreadPoolExecutor(max_workers=args.workers) as executor:
        for dirpath, dirnames, filenames in os.walk(args.src):
            for filename in filenames:
                if filename.endswith(".tif"):
                    executor.submit(process,
                                    os.path.join(dirpath, filename),
                                    args.dst, args=args, box_dim=box)
